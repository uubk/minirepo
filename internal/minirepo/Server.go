/*
 * Copyright 2018 The minirepo authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package minirepo

import (
	"bytes"
	"crypto"
	"crypto/sha256"
	"encoding/hex"
	log "github.com/sirupsen/logrus"
	"github.com/uubk/minirepo/pkg/minirepo/types"
	"golang.org/x/crypto/openpgp"
	"golang.org/x/crypto/openpgp/armor"
	"golang.org/x/crypto/openpgp/packet"
	"gopkg.in/yaml.v2"
	"io/ioutil"
	"os"
	"path"
	"time"
)

// Server contains the functionality of minirepo's commandline interface
// This is supposed to be internal use only ;)
// A Server abstracts the metadata file creation of a repository, including cryptographic operations.
// The normal usage of this class would be:
// ```
// obj := NewServer(...)
// obj.LoadKeypair()
// obj.UpdateMetadata()
// ```
//
type Server struct {
	// Server root. This is where the key material will be stored
	root string
	// Repo root. This is where the files are expected to be
	repo string
	// Server name. This is encoded into the repository key and manifest
	name string

	// Entity used to sign files
	entity *openpgp.Entity
}

// NewServer creates a new minirepo server utility class
func NewServer(root, repo, name string) *Server {
	return &Server{
		root: root,
		repo: repo,
		name: name,
	}
}

// LoadKeypair loads a keypair from files
func (s *Server) LoadKeypair() {
	pubkeyFile := path.Join(s.root, "pub.asc")
	privkeyFile := path.Join(s.root, "priv.asc")
	pubkey := loadKeyFromFile(pubkeyFile, true).(*packet.PublicKey)
	privkey := loadKeyFromFile(privkeyFile, false).(*packet.PrivateKey)
	s.entity = fakeEntity(pubkey, privkey)
}

// GenerateKeypair generates a new keypair for signing
func (s *Server) GenerateKeypair() {
	pubkeyFile := path.Join(s.root, "pub.asc")
	privkeyFile := path.Join(s.root, "priv.asc")

	cfg := packet.Config{
		DefaultCipher:          packet.CipherAES128,
		DefaultHash:            crypto.SHA384,
		DefaultCompressionAlgo: packet.CompressionNone,
		RSABits:                2048,
	}
	// Generate key
	entity, err := openpgp.NewEntity(s.name, "Autogenerated", "", &cfg)
	if err != nil {
		log.WithError(err).Fatal("Couldn't create new entity")
	}

	// Write public key
	pubkeyFD, err := os.OpenFile(pubkeyFile, os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.WithError(err).Fatal("Couldn't create pubkey file")
	}
	defer pubkeyFD.Close()
	out, err := armor.Encode(pubkeyFD, openpgp.PublicKeyType, nil)
	if err != nil {
		log.WithError(err).Fatal("Couldn't create pubkey file armor")
	}
	defer out.Close()
	err = entity.Serialize(out)
	if err != nil {
		log.WithError(err).Fatal("Couldn't write pubkey file")
	}
	out.Close()
	pubkeyFD.Close()

	// Write private key
	privkeyFD, err := os.OpenFile(privkeyFile, os.O_CREATE|os.O_WRONLY, 0600)
	if err != nil {
		log.WithError(err).Fatal("Couldn't create private key file")
	}
	defer privkeyFD.Close()
	out, err = armor.Encode(privkeyFD, openpgp.PrivateKeyType, nil)
	if err != nil {
		log.WithError(err).Fatal("Couldn't create private key file armor")
	}
	defer out.Close()
	err = entity.SerializePrivate(out, &cfg)
	if err != nil {
		log.WithError(err).Fatal("Couldn't write private key file")
	}

	out.Close()
	privkeyFD.Close()
}

// readDir reads the directory 'dir', returing it's contents as a directory entry
func (s *Server) readDir(dir string) types.DirEntry {
	files, err := ioutil.ReadDir(dir)
	if err != nil {
		log.WithField("path", dir).WithError(err).Fatal("Couldn't read directory")
	}
	_, name := path.Split(dir)
	myEntry := types.DirEntry{
		Name: name,
	}
	for _, item := range files {
		if item.IsDir() {
			myEntry.Children = append(myEntry.Children, s.readDir(path.Join(dir, item.Name())))
		} else {
			file := path.Join(dir, item.Name())
			fileContent, err := ioutil.ReadFile(file)
			if err != nil {
				log.WithField("file", file).WithError(err).Fatal("Couldn't read file")
			}
			hashSum := sha256.New().Sum(fileContent)
			myEntry.Children = append(myEntry.Children, types.DirEntry{
				Name: item.Name(),
				Hash: hex.EncodeToString(hashSum),
			})
		}
	}

	return myEntry
}

// UpdateMetadata updates metadata, that is, loads all files, calculates checksums, outputs the YAML file and signs it
func (s *Server) UpdateMetadata() {
	if s.entity == nil {
		log.Fatal("You need to load the keys first!")
	}

	repoStruct := types.RepoInfo{
		Name:      s.name,
		Timestamp: time.Now(),
	}
	files, err := ioutil.ReadDir(s.repo)
	if err != nil {
		log.WithField("path", s.repo).WithError(err).Fatal("Couldn't read directory")
	}
	for _, item := range files {
		if item.IsDir() {
			repoStruct.Contents = append(repoStruct.Contents, s.readDir(path.Join(s.repo, item.Name())))
		}
		// Files in repo root are ignored
	}

	repoStructYAML, err := yaml.Marshal(repoStruct)
	if err != nil {
		log.WithError(err).Fatal("Couldn't marshal repository info struct!")
	}
	repoInfoFile := path.Join(s.repo, "meta.yml")
	err = ioutil.WriteFile(repoInfoFile, repoStructYAML, 0644)
	if err != nil {
		log.WithField("file", repoInfoFile).WithError(err).Fatal("Couldn't write repository info file")
	}

	log.Info("Signing metadata")
	repoSigFile := path.Join(s.repo, "meta.asc")
	outputFD, err := os.OpenFile(repoSigFile, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		log.WithField("file", repoSigFile).WithError(err).Fatal("Couldn't write repository signature file")
	}
	err = openpgp.ArmoredDetachSign(outputFD, s.entity, bytes.NewReader(repoStructYAML), nil)
	if err != nil {
		log.WithField("file", repoSigFile).WithError(err).Fatal("Couldn't create signer")
	}
}
